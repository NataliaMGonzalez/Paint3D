<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RETO</title>
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }
    </style>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
</head>

<body>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three/build/three.module.js';
        import Stats from 'https://unpkg.com/three@0.126.1/examples/jsm/libs/stats.module.js';
        import { OrbitControls } from "https://unpkg.com/three@0.119.0/examples/jsm/controls/OrbitControls.js";

        "using strict";

        let rendered, scene, camera, cameraControl, stats, mesh;
        let objects = [];
        let nModels = 0, positions = [0, 20, -20, 40, -40, 60, -60, 80, -80, 100];

        function randomNumber() {
            return positions[nModels];
        }

        function createQuad() {
            let vertices = [-0.5, 0.5, 0,
            -0.5, -0.5, 0,
                0.5, -0.5, 0,
                0.5, 0.5, 0];
            let indices = [0, 1, 2, 0, 2, 3];

            let geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            let material = new THREE.MeshBasicMaterial({ color: "white", wireframe: false, side: THREE.DoubleSide, transparent: true });
            let quad = new THREE.Mesh(geometry, material);
            quad.position.x = randomNumber();
            quad.position.y = 1;
            quad.name = "Quad";
            console.log(quad);
            return quad;
        }

        function createHeart() {
            let heartShape = new THREE.Shape();

            const x = 0, y = 0;
            heartShape.moveTo(x, y);
            heartShape.moveTo(x + 5, y + 5);
            heartShape.bezierCurveTo(x + 5, y + 5, x + 4, y, x, y);
            heartShape.bezierCurveTo(x - 6, y, x - 6, y + 7, x - 6, y + 7);
            heartShape.bezierCurveTo(x - 6, y + 11, x - 3, y + 15.4, x + 5, y + 19);
            heartShape.bezierCurveTo(x + 12, y + 15.4, x + 16, y + 11, x + 16, y + 7);
            heartShape.bezierCurveTo(x + 16, y + 7, x + 16, y, x + 10, y);
            heartShape.bezierCurveTo(x + 7, y, x + 5, y + 5, x + 5, y + 5);

            let geometry = new THREE.ShapeGeometry(heartShape);
            let material = new THREE.MeshBasicMaterial({ color: "white", wireframe: true });
            let heart = new THREE.Mesh(geometry, material);
            heart.position.x = randomNumber();
            heart.position.y = 1;
            heart.name = "Heart";

            return heart;
        }

        function createFish() {
            let fishShape = new THREE.Shape();

            const x = 0, y = 0;

            fishShape.moveTo(x, y);
            fishShape.quadraticCurveTo(x + 50, y - 80, x + 90, y - 10);
            fishShape.quadraticCurveTo(x + 100, y - 10, x + 115, y - 40);
            fishShape.quadraticCurveTo(x + 115, y, x + 115, y + 40);
            fishShape.quadraticCurveTo(x + 100, y + 10, x + 90, y + 10);
            fishShape.quadraticCurveTo(x + 50, y + 80, x, y);

            let geometry = new THREE.ShapeGeometry(fishShape);

            let material = new THREE.MeshBasicMaterial({ color: "white", wireframe: true });
            let fish = new THREE.Mesh(geometry, material);
            fish.position.x = randomNumber();
            fish.position.y = 1;
            fish.name = "Fish";

            return fish;
        }

        function createDonut() {
            let donutShape = new THREE.Shape();

            const x = 0, y = 0;

            donutShape.moveTo(50, 10);
            donutShape.absarc(10, 10, 40, 0, Math.PI * 2, false);

            let holePath = new THREE.Path();
            holePath.moveTo(20, 10);
            holePath.absarc(10, 10, 10, 0, Math.PI * 2, true);

            donutShape.holes.push(holePath);

            let geometry = new THREE.ShapeGeometry(donutShape);

            let material = new THREE.MeshBasicMaterial({ color: "white", wireframe: true });
            let donut = new THREE.Mesh(geometry, material);
            donut.position.x = randomNumber();
            donut.position.y = 1;
            donut.name = "Donut";

            return donut;

        }

        function init() {

            // RENDERER
            rendered = new THREE.WebGLRenderer({ antialias: true });
            rendered.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(rendered.domElement);

            // SCENE
            scene = new THREE.Scene();

            // CAMERA 
            let fov = 60;
            let aspect = window.innerWidth / window.innerHeight;
            let near = 0.1;
            let far = 10000;
            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.set(0, 0, 50);
            cameraControl = new OrbitControls(camera, rendered.domElement);

            // PLANEHELPER
            let normal = new THREE.Vector3(0, 1, 0);
            let distanceToPlane = 0.;
            let plane = new THREE.Plane(normal, distanceToPlane);
            let planeHelper = new THREE.PlaneHelper(plane, 30, "white");
            scene.add(planeHelper);

            // STATS
            stats = new Stats();
            document.body.appendChild(stats.dom);

            // GUI 
            let gui = new dat.GUI()

            // MODELS

            let sceneModel = {
                colorPalette: [255, 255, 255],
                showStats: true
            }

            let showModels = {
                addQuad: function () {
                    if (nModels < 10) {
                        mesh = createQuad();
                        scene.add(mesh);
                        objects.push(mesh);
                        nModels = nModels + 1;
                    } else {
                        alert("Oops! M치ximo se pueden 10 figuras geometricas");
                    }
                },
                addHeart: function () {
                    if (nModels < 10) {
                        mesh = createHeart()
                        scene.add(mesh);
                        objects.push(mesh);
                        nModels = nModels + 1;
                    } else {
                        alert("Oops! M치ximo se pueden 10 figuras geometricas");
                    }
                },
                addFish: function () {
                    if (nModels < 10) {
                        mesh = createFish();
                        scene.add(mesh);
                        objects.push(mesh);
                        nModels = nModels + 1;
                    } else {
                        alert("Oops! M치ximo se pueden 10 figuras geometricas");
                    }
                },
                addDonut: function () {
                    if (nModels < 10) {
                        mesh = createDonut();
                        scene.add(mesh);
                        objects.push(mesh);
                        nModels = nModels + 1;
                    } else {
                        alert("Oops! M치ximo se pueden 10 figuras geometricas");
                    }
                },

            }

            let modelProps = {
                posX: 0,
                posY: 0,
                posZ: 0,
                rotX: 0,
                rotY: 0,
                rotZ: 0,
                opacity: 1,
                wireframe: true,
                colorPalette: [255, 255, 255]
            }

            // RAYCASTER
            document.addEventListener('mousedown', onDocumentMouseDown);

            function onDocumentMouseDown(event) {
                event.preventDefault();
                var mouse3D = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1,
                    -(event.clientY / window.innerHeight) * 2 + 1, 0.5);
                var raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse3D, camera);
                var intersects = raycaster.intersectObjects(objects);

                if (intersects.length > 0) {
                    mesh = intersects[0].object;

                    modelProps.name = mesh.name;
                    modelProps.posX = mesh.position.x;
                    modelProps.posY = mesh.position.y;
                    modelProps.posZ = mesh.position.z;
                    modelProps.rotX = mesh.rotation.x / Math.PI * 180;
                    modelProps.rotY = mesh.rotation.y / Math.PI * 180;
                    modelProps.rotZ = mesh.rotation.z / Math.PI * 180;
                    modelProps.wireframe = mesh.material.wireframe;
                    modelProps.colorPalette = [mesh.material.color.r * 255, mesh.material.color.g * 255, mesh.material.color.b * 255];
                }
            }

            // MENUS

            // SCENE MENU
            let generalMenu = gui.addFolder("Scene appereance");

            // show plane checkbox
            let chbPlaneHelper = generalMenu.add(planeHelper, "visible").setValue(false).name("Show PlaneHelper");
            // show stats checkbox
            let chbStats = generalMenu.add(sceneModel, "showStats").setValue(true).name("Show Stats").onChange(function (value) {
                if (value) {
                    stats.showPanel(0);
                } else {
                    stats.showPanel(-1);
                }
            });
            // change background color
            let sceneColor = generalMenu.addColor(sceneModel, "colorPalette").name("Color Background").onChange(function (color) {
                rendered.setClearColor(new THREE.Color(color[0] / 256, color[1] / 256, color[2] / 256))
            });

            // ADD MENU
            let addModels = gui.addFolder("Add models");
            addModels.open();

            // add models buttons
            let btnAddQuad = addModels.add(showModels, "addQuad").name("Add Quad")
            let btnAddHeart = addModels.add(showModels, "addHeart").name("Add Heart")
            let btnAddFish = addModels.add(showModels, "addFish").name("Add Fish")
            let btnAddDonut = addModels.add(showModels, "addDonut").name("Add Donut")

            //MODELS MENU
            let modelsMenu = gui.addFolder("Model")

            // POSITION MENU
            let posMenu = modelsMenu.addFolder("Position");

            // positions sliders
            let sliderPosX = posMenu.add(modelProps, "posX").min(-100).max(+100).step(0.5).name("X").listen().onChange(function (value) {
                mesh.position.x = value;
            })
            let sliderPosY = posMenu.add(modelProps, "posY").min(-100).max(+100).step(0.5).name("Y").listen().onChange(function (value) {
                mesh.position.y = value;
            })
            let sliderPosZ = posMenu.add(modelProps, "posZ").min(-100).max(+100).step(0.5).name("Z").listen().onChange(function (value) {
                mesh.position.z = value;
            })

            // ROTATION MENU
            let rotMenu = modelsMenu.addFolder("Rotation");

            // rotation sliders
            let sliderRotX = rotMenu.add(modelProps, "rotX").min(-360).max(+360).step(10).name("X").listen().onChange(function (value) {
                mesh.rotation.x = value * Math.PI / 180
            });
            let sliderRotY = rotMenu.add(modelProps, "rotY").min(-360).max(+360).step(10).name("Y").listen().onChange(function (value) {
                mesh.rotation.y = value * Math.PI / 180
            });
            let sliderRotZ = rotMenu.add(modelProps, "rotZ").min(-360).max(+360).step(10).name("Z").listen().onChange(function (value) {
                mesh.rotation.z = value * Math.PI / 180
            });

            // APPEREANCE MENU
            let appearMenu = modelsMenu.addFolder("Appearance");

            // change background color
            let modelColor = appearMenu.addColor(modelProps, "colorPalette").name("Color").listen().onChange(function (color) {
                mesh.material.color = new THREE.Color(color[0] / 256, color[1] / 256, color[2] / 256);
            });
            // wireframe checkbox
            let chbWireframe = appearMenu.add(modelProps, "wireframe").setValue(true).name("Wireframe").onChange(function (value) {
                mesh.material.wireframe = value;
            });
            let opacity = appearMenu.add(modelProps, "opacity").min(0).max(1).step(0.1).name("Opacity").onChange(function (value) {
                mesh.opacity = value;
            })

            gui.close();

            renderLoop();
        }

        function renderLoop() {
            stats.begin();
            rendered.render(scene, camera); //DRAW SCENE
            stats.end();
            stats.update();
            requestAnimationFrame(renderLoop);
        }

        // EVENT LISTENERS & HANDLERS
        document.addEventListener("DOMContentLoaded", init);

        window.addEventListener("resize", function () {
            rendered.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

    </script>
</body>

</html>